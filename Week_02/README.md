#学习笔记
## 压缩指针
java 对象头大小是 64位系统中xmx小于32G默认开启压缩指针，这时候MarkWorld 64bit Class指针 32bit，
这主要方式是jvm以8bit作为一个单位，32bit就能代表35bit的地址，就是32g内存。当关闭压缩指针对象头位128bit，就是
Class指针为64bit。32位操作系统中对象头为64bit，MarkWorld 32bit，对象指针 32bit。
- 64bit关闭压缩指针的坏处
    -  增加了GC开销：64位对象引用需要占用更多的堆空间，留给其他数据的空间将会减少，从而加快了GC的发生，更频繁的进行GC。
    -  降低CPU缓存命中率：64位对象引用增大了，CPU能缓存的oop将会更少，从而降低了CPU缓存的效率。
       为了能够保持32位的性能，oop必须保留32位。那么，如何用32位oop来引用更大的堆内存呢？
##JVM性能调优
### Young GC 次数过多
适当增大Eden区大小，即减少Young GC 次数，但是每次GC时间会变长；
### 提升速率过高，（即过多的年青代晋升到老年代）
增大young区大小
##NIO
###BIO演进之路
- 单线程处理，每次请求都需要等上一次完成
- 多线程处理，每次请求创建一个线程
- 线程池：使用池化线程
###同步异步 阻塞非阻塞
- 同步/异步关注的是消息通信机制 (synchronous communication/ asynchronous communication) 
    - 所谓同步，就是在发出一个调用时，在没有得到结果之前， 该调用就不返回。
    - 异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果

- 阻塞/非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.即线程状态是等待还是RUNNING
    - 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
    - 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。
###同步阻塞IO（BIO）
- 即所有东西都是单线程执行，假如还没建立链接就一直等待，而且必须等上一个处理完才能进入下一个。
###非阻塞IO 
- 即假如没有建立链接就立即返回，通过不断轮训查看是否有新的链接进来，处理还是和BIO一样，需要等待上一个结果处理
###IO多路复用
- 它与非阻塞IO相比，它同时可以轮训多个Socket，（poll或select函数），当有可读当socket，通知用户线程。
####select和poll函数缺点
- 每次 select 需要将fd从用户态拷贝到内核态
- 每次轮训需要轮训所有到fd，所以需要从内核态传递所有到fd到用户态
- fd有大小限制，最多1024
####epoll函数优点
- 开辟用户态和内核态共享到内存区域，无需fd拷贝
- 使用通知方式，而不是轮训
- fd大小没限制支持10k链接
### 信号驱动IO
- 信号驱动 IO 与 BIO 和 NIO 最大的区 别就在于，在 IO 执行的数据准备阶段 ，不会阻塞用户进程
### 异步IO（AIO）
- 也是在 IO 执行的数据准备阶段 ，不会阻塞用户进程
####Reactor模型
- 即去打印店打印，先拿个号，排到了，老板通知你来打印
####Proactor模型
- 去答应带你打印，先拿个好，到了老板打印完，通知你来拿